# EVMをゼロから実装する。

もしあなたがこれまでにEthereumと関わったことがあるなら、開発者としてであれ、ユーザーとしてであれ、おそらくEVMに出会ったことがあるでしょう。

## EVM
EVMはEthereumの中心的な要素です。Ethereumの実行エンジンであり、「スマートコントラクト」と呼ばれるEthereumプログラムの実行を担当しています。

このチュートリアルでは、EVMをゼロから構築していきます。しかし、これは参照実装ではありません。EVMの動作を理解するために必要ないと考えた実装の詳細は省略します。このチュートリアルは、EVMの基本的な概念を最初の原理から学ぶことを目的としています。

そのため、これを「ミニEVM」と呼びたいと思います。実際に動くものですが、簡略化されたバージョンです。Ethereumプログラムを入力として受け取り、それを実行する仮想マシンです。

では、EVMとは何なのでしょうか？それは、Ethereumバイトコードを実行する仮想マシンです。

## 仮想マシン
仮想マシンとは、実際のコンピュータ上で動く「仮想のコンピュータ」のようなものです。別途物理的なマシンが必要になるのではなく、既に持っているコンピュータ上でソフトウェアとしてすべてが行われます。

実際のコンピュータと同じように、仮想マシンにも独自の言語があります。EVMの場合、その言語はEthereumバイトコードと呼ばれます。

## バイトコード
バイトコードとは、EVMが理解できる命令（オペコード）の一覧です。オペコードは、ADD（加算）やSUBTRACT（減算）、STOP（停止）などの操作を意味します。

以下の表にいくつかのオペコードが示されています：重要なのは、EVMはADDやSUBTRACTの意味を理解しているわけではないということです。EVMはオペコードの識別子しか認識しません。例えば、ADDの場合は0x01です。

| OPCODE | NAME | DESCRIPTION               |
|--------|------|---------------------------|
| 0x00   | STOP | Halts Execution            |
| 0x01   | ADD  | Addition operation         |
| 0x02   | MUL  | Multiplication operation   |
| 0x03   | SUB  | Subtraction operation      |
| 0x04   | DIV  | Integer division operation |

そのため、有効なプログラムは次のように見えるでしょう：604260005260206000F3。これはEVMが解釈できるものです。

現在、144種類のオペコードがあります。それらすべてをここで確認できます。この数は固定されておらず、新しいオペコードが追加されたり、古いオペコードが頻繁に廃止されたりします。

## Solidity、Vyper、Huff
開発者として、ほとんどの場合、バイトコードを直接書きたくはないでしょう。これは非常に遅く、エラーが発生しやすいためです。ここでSolidityやVyperのような高級プログラミング言語が役立ちます。

ただし、SolidityやVyperのファイルは単なるテキストファイルです。これはEVMが理解できるものではありません。テキストファイルをEVMバイトコードに変換するプログラムが必要です。このプログラムをコンパイラと呼びます。

プログラミング言語がEVMバイトコードに変換（コンパイル）できる場合、その言語はEVMをターゲットにしていると言います。

## Ethereum vs Bitcoin
では、Ethereumが特別な理由は何でしょうか？Bitcoinのようなそれ以前のブロックチェーンと比較して。

Ethereumが「特別」なのは、それが汎用的であり、チューリング完全であるからです。つまり、任意のプログラムをEVM上で実行できるということです（ガスやメモリの制約を無視すれば）。

Bitcoinにも「ビットコインスクリプト」と呼ばれるプログラミング機能がありますが、重要なのは、ビットコインスクリプトはチューリング完全ではないという点です。ビットコインスクリプトでは実装できないプログラムが存在します。しかし、EVMではそのような制限はありません。

## 概要
私たちはミニEVMを一から構築していきます。まずはスタックから始め、次にメモリとストレージに移ります。その後、オペコードを実装していきますが、これが最も時間のかかる作業です。

これらの構成要素をすべて構築した後、それらを組み合わせて独自のEVMを作成します。最終的には、私たちのEVMを使っていくつかのプログラムを実行します。

重要なのは、私たちのミニEVMは完全に孤立した環境に存在しているということです。他のコントラクトやアカウントについては何も知りません。外部の世界とやり取りする必要がある機能は、モック（模擬）されています。これはシンプルさを保つための意図的な選択です。

## 前提条件
- Python
- 16進数の数値

## ガス
ガスは非常に重要な概念です。計算作業の量を測るためのものです。例えば、ストレージに値を保存したり、メモリのサイズを拡張したり、算術演算を実行したりする際の計算作業の量を測ります。

ガスが必要な理由は、計算作業に使えるリソースが限られているからです。例えば、DDOS攻撃を防ぐために、プログラムを実行するにはユーザーがガスを消費しなければならない仕組みになっています。

ガスはETH（イーサリアム）で支払う必要があります。もしバイトコードを実行中にガスが不足すると、その時点で実行が停止します。

## スタック
スタックは非常にシンプルなデータ構造です。ただし、1つ制約があります。それは、スタックの「一番上」にしか直接操作ができないという点です。

新しい値をスタックの一番上に追加する（プッシュ）ことができ、すでに存在する値を取り出す（ポップ）ことができます。

スタックを説明するのに「皿の積み重ね」が良い比喩になります。皿を上に追加したり、上から取り出したりするのと同じように、スタックもそのように機能します。

EVMのスタックには最大1024個の項目を保持することができます。スタック上の各項目は最大で256ビット（32バイト）の値です。

## メモリ
メモリはバイト（byte）のリストです。各バイトは個別にアクセスできます。

RAM（ランダムアクセスメモリ）と似ていて、最初は完全に空の状態から始まります。また、揮発性があり、実行が終わるとメモリはリセットされます。

各メモリセルには1バイト（8ビット）のデータを保持できます。つまり、0から255の間の数値が入ります。

メモリは、インデックスやオフセットを使ってアクセスできるシンプルなリストとして表現します。

例えば、オフセットが2であれば、インデックス2に格納されているバイトを取得できます。また、サイズと組み合わせることで、バイトのブロックを取得できます。オフセット2、サイズ5の場合、インデックス2からインデックス7までのバイトを返します。

メモリのサイズを拡大するには、ガスを消費しますが、その消費量は線形ではなく、サイズが大きくなるほどコストが増えます。

それでは、メモリ拡張に伴うガスの計算を追加しましょう。

次に、いくつかのメモリを作成します。 オフセット0に4つの値を格納します。 読み込みは、可能であれば常に32バイトを返します。

## 応用
これが、実際にメモリ拡張のためのガスコストが計算される方法です。

## ストレージ
ストレージはキーと値のマッピングです。実用的にはキーの数は無限にあると考えて良いです。値は最大32バイトまで格納できます。すべての値は初期状態では0に設定されています。

これは、コンピュータのSSDのようなものです。ストレージは揮発性ではなく、データは消えません。

ストレージは辞書（ディクショナリ）として表現します。

## ウォーム／コールド

ウォーム（warm）またはコールド（cold）のストレージスロットにアクセスするかによって、ガスの消費量が異なります。スロットがウォームであるとは、以前にアクセスされたことがある場合を指します。そうでない場合はコールドと呼ばれます。コールドなスロットにアクセスする場合、ウォームなスロットにアクセスするよりも多くのガスが必要です。

このロジックは、キャッシュを追跡することで実装します。ストレージスロットを読み込む際、そのスロットのキーをキャッシュに保存します。キーがキャッシュに存在する場合、そのスロットはウォームとみなされます。

### EVMの状態
EVMは状態機械（ステートマシン）です。有効なEthereumプログラムやバイトコードは、その状態を操作できます。

特定のオペコードは、この状態を操作する命令です。

### プログラムカウンタ (pc)
プログラムカウンタは、EVMが次に実行するオペコードを指し示します。

### スタック / メモリ / ストレージ
これらはすべてEVMの状態の一部であり、EVMがデータを操作・保存する領域です。

### プログラム
現在のプログラムのバイトコードを格納する場所です。実行中は変更できないため、不変です。

### 送信者
現在このプログラムを実行しているアカウントのアドレスです。Solidityでいうmsg.senderに相当します。

### ガス
現在のガスの残量と、これまでに消費したガス量を追跡します。ほとんどのオペコードはガスカウンタを減らします。

### 値 (Value)
現在の実行で消費できるEther（wei）の量です。

### Calldata
プログラムへの入力データです。

### フラグ
2つのフラグを追跡します。stop_flagとrevert_flagです。いずれかがTrueになると、現在の実行が停止します。

### 戻りデータ (Returndata)
EVMは実行後にデータを返すことができます。このデータをreturnに格納します。

### ログ
いくつかのオペコードは実行時にログを出力します。その結果がここに保存されます。

## オペコード (Opcodes)
オペコードは、EVMが実行できる命令です。オペコードにはさまざまなカテゴリがあり、いくつかは算術や論理演算に関係し、他はメモリ、ストレージ、スタックを扱います。

### 実装
次のノートブックでは、これらのオペコードのほとんどを実装します。すべてのオペコードに共通しているのは、EVMの現在の状態を操作することです。そのため、EVMのインスタンスをパラメータとして受け取る関数を各オペコードごとに作成します。

各オペコードには固有の識別子があります。それは、そのオペコードを表す数値です。すべてのオペコードは1バイトを超えないため、16進数で表現すると非常に便利です。

オペコードを扱いやすくするため、私たちはそれに短くて説明的な名前を付けます。すべてのオペコードはここで確認できます。

## バイトコード (Bytecode)
EVMについて理解したので、バイトコードについて少し説明しましょう。バイトコードはEVMによって実行されます。

有効なバイトコードは、有効なオペコードとそのオペランド（操作対象）をリスト化したものです。オペコードとオペランドのリストをプログラムと呼びます。

### シンプルなプッシュ (Simple Push)
例えば、0x42をスタックにプッシュするプログラムは次のようになります。

### 命令とデータ
ご覧のように、バイトコードは命令とデータの両方で構成されています。データと命令が混ざらないようにするのはプログラム作成者の責任です。

これを「フォン・ノイマン・アーキテクチャ」と呼びます。

### シンプルな加算 (Simple Add)
もう1つの簡単なプログラムとして、次のように書けます。ここでは、0x42と0xFFをスタックにプッシュして、それらを加算し、その結果を再びスタックに置きます。

このプログラムを実行すると、スタックには321という1つの要素が残るはずです。

次のステップでは、私たちが作ったEVMを使って、これらのプログラムを実際に実行していきます。

## 注意事項

すべてのノートブックはここで利用可能です。もし誤りを見つけた場合は、GitHubにIssueを作成するか、さらに良ければプルリクエストを作成してください ;)
